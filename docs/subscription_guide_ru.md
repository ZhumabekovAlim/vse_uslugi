# Руководство по подпискам исполнителей

Этот документ описывает полную серверную логику подписок для исполнителей,
включая структуру таблиц, проверку прав при управлении объявлениями,
работу с откликами и процесс покупки/продления подписок через AirbaPay.
Все сведения относятся к текущей реализации на стороне бэкенда.

## 1. Данные и таблицы

### 1.1 `executor_subscriptions`
Таблица создаётся миграцией `000084_executor_subscriptions` и хранит по одной
строке на сочетание `user_id` + `subscription_type`
(`service`, `rent` или `work`). Поля:

| Поле | Описание |
|------|----------|
| `id` | Внутренний идентификатор записи. |
| `user_id` | Исполнитель, владелец подписки. |
| `subscription_type` | Тип подписки (`service`, `rent`, `work`). |
| `expires_at` | Дата и время окончания оплаченного периода. |
| `created_at`, `updated_at` | Аудитные поля. |

По окончании срока подписки сервер переводит объявления пользователя данного
типа в архив (см. раздел 2).

### 1.2 `subscription_responses`
Эта таблица (миграция `000053_subscription_responses`) ведёт баланс откликов.
Ключевые поля: `remaining` (количество доступных откликов), `status`,
`renews_at` (ожидаемая дата автопродления) и `monthly_quota`. Все операции
списания/возврата откликов используют именно эту таблицу (см. раздел 4).

## 2. Проверка подписок при работе с объявлениями

### 2.1 Создание и активация
Каждый доменный сервис (`ServiceService`, `RentService`, `WorkService`) перед
созданием объявления вызывает
`SubscriptionRepository.HasActiveSubscription(userID, type)` и возвращает
ошибку `services.ErrNoActiveSubscription*`, если активного периода нет.
При обновлении записи до статуса `active` выполняется повторная проверка,
если объявление ранее было неактивным (файлы `internal/services/service_service.go`,
`rent_service.go`, `work_service.go`).

Аналогичная валидация действует при переводе объявления из архива в активный
статус: методы `ArchiveService`, `ArchiveRent`, `ArchiveWork` читают владельца,
проверяют подписку и разрешают восстановление только при действующей
подписке соответствующего типа.

### 2.2 Объявления-«дубликаты»
Сервисы объявлений-заказов (`AdService`, `RentAdService`, `WorkAdService`)
тоже проверяют подписку перед активацией (файлы `internal/services/*ad_service.go`).
Это гарантирует, что у исполнителя нет активных предложений без оплаченной
подписки.

### 2.3 Автоматическая архивация
`HasActiveSubscription` не только возвращает булево значение, но и вызывает
`ArchiveListingsByType`, если подписка просрочена. Метод обновляет статусы во
всех таблицах домена (`service`, `rent`, `work`) на `archive`. Таким образом,
как только `expires_at` <= `NOW()`, пользователь теряет возможность держать
активные объявления до продления подписки.

## 3. Продление подписок

Метод `SubscriptionRepository.ExtendSubscription` обеспечивает последовательное
продление. Если подписка уже есть и её срок ещё не истёк, новое значение
`expires_at` вычисляется от текущего срока; иначе отсчёт ведётся от текущего
момента. Это позволяет, например, добавить два месяца к оставшемуся месяцу и
получить суммарно три месяца действия.

Метод работает в транзакции, поэтому созданный инвойс всегда приводит к
обновлению либо вставке записи `executor_subscriptions`.

## 4. Баланс откликов

### 4.1 Списание
Все три сервиса откликов (`AdResponseService`, `RentAdResponseService`,
`WorkAdResponseService`) после успешного сохранения отклика вызывают
`SubscriptionRepository.ConsumeResponse`. Если баланс равен нулю, метод
возвращает `models.ErrNoRemainingResponses`, отклик удаляется и пользователю
возвращается ошибка. Это гарантирует, что отклик нельзя создать без списания
баланса.

### 4.2 Откат и возврат
Если дальнейшие шаги (создание чата, подтверждения и т.д.) завершаются с
ошибкой, сервисы откликов вызывают `RestoreResponse`, который возвращает
списанный отклик в баланс, а сам отклик удаляет.

При отмене отклика пользователем метод `Cancel*Response` удаляет запись и
возвращает отклик в баланс через `RestoreResponse`.

### 4.3 Требование хотя бы одного активного объявления
Сервер предоставляет фронтенду число активных объявлений исполнителя через
`SubscriptionService.GetProfile` → `SubscriptionRepository.CountActiveExecutorListings`.
Запрос суммирует активные записи в таблицах `service`, `ad`, `work`,
`work_ad`, `rent` и `rent_ad`. Это значение можно использовать для проверки
условия «минимум одно активное объявление» перед предоставлением откликов
или отображением UI.

## 5. Чтение статусов подписки

Два публичных маршрута возвращают состояние подписки:

1. `GET /subscription/:user_id` — требует авторизации; отдаёт детальный профиль
`SubscriptionProfile` с информацией по каждому типу подписки, числом оставшихся
дней, балансом откликов и количеством активных объявлений.
2. `GET /subscriptions` — краткая сводка для текущего пользователя, содержит
булевые флаги активности и оставшийся баланс откликов.

Оба маршрута используют `SubscriptionHandler` и сервис из
`internal/services/subscription_service.go`.

## 6. Покупка подписки через AirbaPay

### 6.1 Создание платежа: `POST /airbapay/pay`
Маршрут доступен без авторизации (используется внутренними клиентами).
Тело запроса:

```json
{
  "user_id": 42,
  "amount": 15000,
  "description": "Subscription order",
  "subscription": {
    "type": "service",
    "months": 3
  }
}
```

* `user_id`, `amount`, `description` — обязательные поля счёта.
* `subscription.type` — один из `service|rent|work`.
* `subscription.months` — положительное целое.
* Дополнительно можно передать `target` для пополнения балансов в модулях
такси или курьера. Для подписок `target` не нужен: хендлер сам создаёт
внутренний `invoice_target` с типом `subscription_purchase`.

В ответ сервер создаёт внутренний инвойс, добавляет указанные таргеты и
возвращает структуру AirbaPay (`inv_id`, `order_id`, `payment_url`, `status`).

### 6.2 Вебхук AirbaPay: `POST /api/v1/payments/airbapay/webhook`
После оплаты AirbaPay отправляет JSON-пейлоад на вебхук. Обработчик:

1. Считывает тело и проверяет, нужно ли делегировать в модуль такси (наличие
заголовка `X-AirbaPay-Signature`).
2. В остальных случаях парсит пейлоад через `AirbapayService.ParseCallback`
и валидирует подпись (RSA).
3. Находит инвойс по `invoice_id`, отмечает его оплаченным и обрабатывает все
связанные `invoice_targets`.
4. Для `subscription_purchase` десериализует `type` и `months` и вызывает
`SubscriptionRepository.ExtendSubscription`, что продлевает срок подписки и,
при необходимости, снимает объявления с архива.

Если AirbaPay сообщает об ошибке (`status = failure|error|...`), инвойс помечается
как `failed` и никакие таргеты не выполняются.

## 7. Типовые сценарии

1. **Создание объявления без подписки**: запрос к `/service` приводит к
ошибке `subscription required` из `ServiceService.CreateService`, потому что
`HasActiveSubscription` возвращает `false` и дополнительно переводит старые
объявления в архив.
2. **Продление действующей подписки**: пользователь создаёт оплату с
`months = 2`, когда до окончания осталось 1 месяц. Вебхук вызывает
`ExtendSubscription`, который добавляет 2 месяца к существующему `expires_at`
→ итог 3 месяца.
3. **Отклик без доступного баланса**: `AdResponseService.CreateAdResponse`
пытается списать отклик через `ConsumeResponse`, получает ошибку и полностью
откатывает создание отклика, сохраняя целостность баланса.

Этот процесс покрывает все маршруты (`/airbapay/pay`,
`/api/v1/payments/airbapay/webhook`, `/subscription/:user_id`, `/subscriptions`)
и внутренние проверки, требуемые для корректной работы подписок исполнителей.
