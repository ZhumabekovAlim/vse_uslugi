# Полное руководство по платежам AirbaPay

Документ описывает унифицированный платежный сценарий, который используется для покупки услуг в основном модуле (клики и объявления), а также для пополнения баланса водителей такси и курьеров. Все примеры и API приведены на русском языке.

## 1. Общая архитектура

1. Клиентское приложение создаёт оплату через `POST /airbapay/pay`. Бэкенд фиксирует счёт (`invoice`) в базе и запрашивает платёжную ссылку AirbaPay.
2. Пользователь переходит по `payment_url` и оплачивает счёт на стороне AirbaPay.
3. AirbaPay вызывает `POST /api/v1/payments/airbapay/webhook`.
   * Если заголовок `X-AirbaPay-Signature` присутствует — запрос проксируется в такси-модуль для проверки HMAC-подписи (поддержка старого протокола).
   * В остальных случаях бэкенд валидирует подпись AirbaPay, отмечает счёт как оплаченный и выполняет связанные действия (покупка услуг, пополнение балансов).
4. Клиент может получить историю платежей через `GET /airbapay/history/:user_id`.

В базе хранятся две сущности:

* Таблица `invoices` — основной счёт (`inv_id`, `user_id`, `amount`, `status`, `description`).
* Таблица `invoice_targets` — действия, которые нужно выполнить после оплаты (`target_type`, `target_id`, `payload_json`, `processed_at`).

## 2. Создание платежа

### 2.1. Endpoint

```
POST /airbapay/pay
Content-Type: application/json
```

### 2.2. Тело запроса

```json
{
  "user_id": 42,
  "amount": 1500.0,
  "description": "Покупка 10 откликов",
  "target": {
    "type": "taxi_driver_balance",
    "id": 123,
    "amount": 1500
  }
}
```

Поля:

| Поле | Обязательно | Описание |
|------|-------------|----------|
| `user_id` | да | Идентификатор пользователя в основной базе. |
| `amount` | да | Сумма платежа в тенге (можно дробное значение). |
| `description` | да | Текст, который будет записан в счёт и передан в AirbaPay. Используется для классификации покупок (клики, объявления). |
| `target` | нет | Опциональный блок для пополнения модульных балансов. |
| `target.type` | да (если `target` задан) | Допустимые значения: `taxi_driver_balance`, `courier_balance`. |
| `target.id` | да | Внутренний ID водителя или курьера. |
| `target.amount` | нет | Целая сумма пополнения. Если не указана — используется округлённое значение `amount`. |

> **Важно:** `target.amount` всегда трактуется как целое количество тенге. Если требуется пополнить баланс на сумму, отличную от общей суммы счёта, явно задайте это поле.

### 2.3. Ответ

```json
{
  "inv_id": 987,
  "order_id": "987",
  "invoice_id": "1234567",
  "payment_url": "https://pay.airbapay.kz/...",
  "status": "CREATED"
}
```

* `inv_id` — внутренний идентификатор счёта (используется в вебхуке).
* `order_id` — совпадает с `inv_id`, оставлен для обратной совместимости.
* `invoice_id` — идентификатор платежа на стороне AirbaPay.
* `payment_url` — ссылка для редиректа пользователя.
* `status` — статус AirbaPay при создании (обычно `CREATED`).

Созданный счёт имеет статус `pending` в таблице `invoices`.

## 3. Статусы и переходы

| Источник | Статус | Действие в системе |
|----------|--------|--------------------|
| AirbaPay (callback) | `success`, `succeeded`, `paid`, `done`, `approved`, `auth` | Счёт помечается как `paid`, выполняются все привязанные действия. |
| AirbaPay (callback) | `failure`, `failed`, `cancelled`, `rejected`, `error` | Счёт помечается как `failed`. |
| AirbaPay (callback) | любое другое значение | Сохраняется в `invoices.status` без модификаций. |
| Система | Ошибка при создании платежа | Счёт обновляется в `status = 'error'`. |

После успешной оплаты `invoice_targets.processed_at` заполняется для каждого выполненного действия, что предотвращает повторные зачисления при повторных вебхуках.

## 4. Webhook AirbaPay

### 4.1. Endpoint

```
POST /api/v1/payments/airbapay/webhook
Content-Type: application/json
```

### 4.2. Параметры безопасности

* Если заголовок `X-AirbaPay-Signature` присутствует — запрос перенаправляется в модуль такси для HMAC-валидации старых webhook’ов.
* Для новых уведомлений используется встроенная проверка подписи AirbaPay (RSA). Поля для расчёта подписи: `id + invoice_id + amount + currency + status + description`.

### 4.3. Пример тела уведомления

```json
{
  "id": "c6d5...",
  "invoice_id": "987",
  "amount": 1500,
  "currency": "KZT",
  "status": "success",
  "description": "Покупка 10 откликов",
  "sign": "BASE64_SIGNATURE"
}
```

### 4.4. Ответ сервера

```json
{
  "status": "ok",
  "invoice_id": "987"
}
```

Если подпись некорректна или `invoice_id` не найден — сервер вернёт `400 Bad Request`.

## 5. Выполнение действий после оплаты

После того как счёт помечен как `paid`, сервер обрабатывает все записи `invoice_targets` для данного `invoice_id`:

1. **Пополнение баланса водителя такси (`taxi_driver_balance`)**
   * Вызывается `taxi.DepositDriverBalance` с `driver_id = target.id` и суммой из `target.amount` (или округлённой суммой счёта).
   * Пополнение производится транзакционно в модуле такси.

2. **Пополнение баланса курьера (`courier_balance`)**
   * Вызывается `courier.DepositBalance` с `courier_id = target.id`.
   * Сумма изменяет поле `balance` в таблице `couriers`.

3. **Покупка услуг основного модуля**
   * Выполняется автоматически на основании `description` счёта:
     * `"отклик"` или `"response"` с числом `10` — добавляет 10 откликов пользователю (`SubscriptionRepository.AddResponsesBalance`).
     * `"subscription"`, `"1 объяв"`, `"1 ad"`, `"1 listing"` — добавляет 1 слот объявления (`SubscriptionRepository.AddListingSlots`).
   * Если описание не распознано — дополнительных действий не выполняется.

Все ошибки при выполнении действий логируются, но не блокируют обработку следующих целей. Повторный вебхук попытается обработать только те цели, у которых `processed_at` ещё пустой.

## 6. История платежей

```
GET /airbapay/history/:user_id
Authorization: Bearer <token>
```

Возвращает массив объектов:

```json
[
  {
    "id": 987,
    "user_id": 42,
    "amount": 1500,
    "description": "Покупка 10 откликов",
    "status": "paid",
    "created_at": "2024-03-10T12:34:56Z"
  }
]
```

## 7. Типовые сценарии

### 7.1. Покупка откликов без пополнения баланса

1. Клиент вызывает `POST /airbapay/pay` без поля `target`.
2. После оплаты AirbaPay присылает webhook со статусом `success`.
3. Система начисляет 10 откликов пользователю по описанию счёта.

### 7.2. Пополнение баланса водителя такси

1. Клиент вызывает `POST /airbapay/pay` с `target.type = "taxi_driver_balance"` и `target.id = <driver_id>`.
2. После успешной оплаты водитель получает пополнение баланса на сумму `target.amount` (или на общую сумму счёта).

### 7.3. Пополнение баланса курьера

1. Клиент вызывает `POST /airbapay/pay` с `target.type = "courier_balance"` и `target.id = <courier_id>`.
2. После успешной оплаты поле `balance` курьера увеличивается.

## 8. Диагностика и повторная обработка

* Для проверки статуса оплаты используйте историю платежей или прямой запрос к таблице `invoices`.
* Если AirbaPay повторно отправит webhook, уже обработанные цели будут проигнорированы благодаря `processed_at`.
* При ошибках пополнения баланса проверьте логи: сообщения вида `"airbapay: execute target failed"` содержат конкретную причину.

## 9. Дополнительные советы

* Убедитесь, что переменные окружения AirbaPay (`AIRBAPAY_USERNAME`, `AIRBAPAY_PASSWORD`, `AIRBAPAY_TERMINAL_ID`, `AIRBAPAY_BASE_URL`, `AIRBAPAY_SUCCESS_URL`, `AIRBAPAY_FAILURE_URL`, `AIRBAPAY_CALLBACK_URL`) заполнены.
* Для интеграции с фронтом используйте `payment_url` и редиректы `GET /airbapay/success` / `GET /airbapay/failure`.
* В тестовой среде можно вручную отправить webhook на `/api/v1/payments/airbapay/webhook`, чтобы проверить обработку.
