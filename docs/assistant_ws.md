# WebSocket чата с ИИ

Ниже описан протокол работы `/ws/assistant`, который позволяет задавать вопросы ИИ-ассистенту по WebSocket вместо REST запроса `/ai/ask`.

## Как подключиться
1. Выполните WebSocket-handshake к `wss://<домен бэкенда>/ws/assistant` (или `ws://` при локальной отладке). Хендлер не требует авторизации и использует тот же апгрейдер, что и другие WS в сервисе.
2. После апгрейда сервер:
   * ограничивает размер входящего кадра 1 МБ;
   * ждёт любые клиентские сообщения не дольше 120 секунд (дедлайн продлевается Pong'ами);
   * каждые 15 секунд отправляет `ping`, ожидая стандартный `pong` от клиента. Если не отвечать, соединение закроется.

> **Важно.** Хендлер автоматически продлевает `read deadline` при получении Pong, поэтому большинство WebSocket-библиотек справятся с этим без дополнительных действий. Важно не блокировать обработку входящих ping/pong фреймов.

## Формат сообщений
Все сообщения — JSON. Клиент отправляет только тип `ask` (можно опустить поле `type`, оно по умолчанию считается `ask`). Сервер возвращает `answer` или `error`.

### Входящее сообщение
```json
{
  "type": "ask",
  "request_id": "optional-id-123",
  "question": "Как оформить доставку?",
  "locale": "ru",
  "role": "user",
  "use_llm": true,
  "max_kb": 5
}
```
| Поле        | Обяз. | Описание |
|-------------|-------|----------|
| `type`      | нет   | Сейчас поддерживается только `"ask"`. Любое другое значение вернёт `error`. |
| `request_id`| нет   | Сквозной идентификатор, будет отражён в ответе `answer`/`error`, чтобы можно было сопоставить запрос и ответ при мультиплексировании. |
| `question`  | да    | Текст вопроса. Пустые строки запрещены. |
| `locale`    | нет   | Язык ответа. По умолчанию `"ru"`. |
| `role`      | нет   | Роль автора (по умолчанию `"user"`). |
| `use_llm`   | нет   | Включить/выключить LLM; по умолчанию `true`. |
| `max_kb`    | нет   | Лимит на количество записей из internal KB (минимум 1, максимум 20). По умолчанию `5`. |

Если `question` пустой или тип неизвестен, сервер немедленно отвечает сообщением `error` и ждёт следующую попытку.

### Ответы сервера
```json
{
  "type": "answer",
  "request_id": "optional-id-123",
  "result": {
    "answer": "Чтобы оформить доставку...",
    "sources": [
      {"title": "FAQ", "url": "https://..."}
    ]
  }
}
```
```json
{
  "type": "error",
  "request_id": "optional-id-123",
  "error": "question is required"
}
```
* `answer` — возвращается при успешном ответе `AskService`. Поле `result` полностью совпадает с REST-ответом `/ai/ask` (`services.AskResult`).
* `error` — структурированное описание проблемы. Ошибки делятся на валидационные (например, пустой вопрос) и системные (не удалось получить ответ от сервиса).

Любой ответ содержит `request_id`, если он был передан клиентом.

## Жизненный цикл запроса
1. Клиент отправляет `ask` с вопросом.
2. Хендлер формирует `services.AskParams` (подставляет значения по умолчанию, обрезает пробелы, нормализует границы `max_kb`).
3. Вызывается `app.assistantHandler.Service.Ask(...)` с таймаутом 30 секунд. Если сервис не ответил вовремя или вернул ошибку, клиент получит `type=error` с сообщением `"failed to get answer"`.
4. Успешный результат возвращается одним JSON-кадром `answer` и соединение остаётся открытым — можно задавать следующий вопрос в рамках того же WS.

## Примеры
### JavaScript (браузер)
```javascript
const socket = new WebSocket("wss://api.example.com/ws/assistant");

socket.addEventListener("open", () => {
  socket.send(JSON.stringify({
    type: "ask",
    request_id: crypto.randomUUID(),
    question: "Как восстановить пароль?"
  }));
});

socket.addEventListener("message", event => {
  const payload = JSON.parse(event.data);
  if (payload.type === "answer") {
    console.log("Ответ:", payload.result.answer);
  } else {
    console.error("Ошибка:", payload.error);
  }
});
```

### CLI (wscat)
```
wscat -c ws://localhost:4000/ws/assistant
> {"type":"ask","question":"Что умеет бот?"}
< {"type":"answer","result":{"answer":"..."}}
```

## Что произойдёт при разрыве связи
- Если клиент не отвечает на `ping` (15 секунд), сервер закроет соединение с кодом `Going Away`.
- Если превышен лимит чтения или JSON некорректен, соединение закроется с `CloseNormalClosure` после отправки ошибки.
- Клиент всегда может переподключиться и продолжить диалог, отправив новый `ask`.
